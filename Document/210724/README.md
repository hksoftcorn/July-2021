# 업무일지

### ✔ Summary

- [x] 08:00~09:30 방청소
- [x] 09:30~11:30 APS
- [x] 16:30~22:30 APS 헤헤,,, 밀렸던 알고리즘 풀어야지😋
- [ ] ~~22:00~24:00 Vue.js 3 : TODO & 인피니티 스크롤 적용(내일까지)~~
- [ ] ~~00:00~00:00 PJT 레퍼런스 찾기,~~ 



## ✨ 오늘 배운 내용

| 알고리즘         | 풀이 가능한 문제들의 특징                  | 풀이 가능한 문제 및 알고리즘                                 |
| ---------------- | ------------------------------------------ | ------------------------------------------------------------ |
| DP               | - 최적 부분 구조<br />- 중복된 하위 문제들 | - 0~1 배낭 문제<br />- 피보나치 수열<br />- 다익스트라 알고리즘 |
| Greedy           | - 최적 부분 구조<br />- 탐욕 선택 속성     | - 분할 가능 배낭 문제<br />- 다익스트라 알고리즘             |
| Divide & Conquer | - 최적 부분 구조                           | - 병합 정렬<br />- 퀵 정렬                                   |

- [APS](./APS/APS.md)

- 최적 부분 구조

  서울에서 부산을 가려고 한다. 서울에서 대구가는 경로 중 최적의 경로의 길이 + 대구에서 부산에 가는 경로 중 최적의 경로의 길이를 더하면 서울에서 부산까지 가는 경로의 최소 거리가 나온다. 만약 서울에서 부산으로 직통도로가 개설된다면 더 이상 최적 부분 구조가 아니므로, DP와 Greedy 둘 다 적용이 불가능하다.


## 👀 수행한 업무 및 작성한 코드

- Greedy
- DC
- DP



## 🐱‍💻 아쉬운 점 & 느낀 점

- 문제를 풀어봅시다.
- 아직 이해가 가지 않는 DP 배낭문제

```python
cargo = [[4, 12], [2, 1], [10, 4], [1, 1], [2, 2]]
def greedy_knapsack(cargo):
    capacity = 15
    pack = []
    # 짐 갯수 : 5 + 1
    # 저장 가능한 용량 : 15 + 1
    # 6 x 16 배열 생성됨
    # 1열 전체, 1행 전체는 0으로 채워진다.
    for i in range(len(cargo) + 1):
        pack.append([])
        for c in range(capacity + 1):
            if i == 0 or c == 0:
                pack[i].append(0)
            elif cargo[i - 1][1] <= c:
                pack[i].append(
                    max(
                        cargo[i - 1][0] + pack[i - 1][c - cargo[i - 1][1]],
                        pack[i - 1][c]
                    ))
            else:
                pack[i].append(pack[i - 1][c])
                
	return pack[-1][-1]
    
    
```



 

